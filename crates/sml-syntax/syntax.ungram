Root = Dec

Dec = DecInSeq*
DecInSeq = DecOne ';'?

// we merge many kinds of decs that are separate in the grammar (top-level, structure-level, and
// regular) so that we may parse them and reject them later if necessary.
DecOne =
  HoleDec
| ValDec
| FunDec
| TyDec
| DatDec
| DatCopyDec
| AbstypeDec
| ExDec
| OpenDec
| InfixDec
| InfixrDec
| NonfixDec
| DoDec
| LocalDec
| StructureDec
| SignatureDec
| FunctorDec
// expressions are not actually decs, but we can parse them, accept them at only the top level, and
// reject them everywhere else with a good error mesage.
| ExpDec

HoleDec = '...'
ValDec = 'val' TyVarSeq ValBind*
FunDec = 'fun' TyVarSeq '|'? FunBind*
TyDec = 'type' TyBind*
DatDec = 'datatype' DatBind* WithType?
DatCopyDec = lhs_kw:'datatype' 'Name' '=' rhs_kw:'datatype' Path
AbstypeDec = 'abstype' DatBind* WithType? 'with' Dec 'end'
ExDec = 'exception' ExBind*
OpenDec = 'open' Path*
InfixDec = 'infix' 'IntLit'? NameStarEq*
InfixrDec = 'infixr' 'IntLit'? NameStarEq*
NonfixDec = 'nonfix' NameStarEq*
DoDec = 'do' Exp
LocalDec = 'local' local_dec:Dec 'in' in_dec:Dec 'end'
StructureDec = 'structure' StrBind*
SignatureDec = 'signature' SigBind*
FunctorDec = 'functor' FunctorBind*
ExpDec = Exp

ValBind = 'rec'? Pat '=' Exp 'and'?
FunBind = FunBindCase* 'and'?
TyBind = TyVarSeq 'Name' '=' Ty 'and'?
DatBind = TyVarSeq 'Name' '=' '|'? ConBind* 'and'?
ConBind = 'op'? NameStarEq OfTy? '|'?
ExBind = 'op'? NameStarEq ExBindInner? 'and'?
StrBind = 'Name' AscriptionTail? '=' StrExp 'and'?
SigBind = 'Name' '=' SigExp 'and'?
FunctorBind =
  functor_name:'Name'
  '(' FunctorArg ')' AscriptionTail?
  '=' body:StrExp 'and'?

FunBindCase = FunBindCaseHead Pat* TyAnnotation? '=' Exp '|'?
FunBindCaseHead = PrefixFunBindCaseHead | InfixFunBindCaseHead
PrefixFunBindCaseHead = 'op'? NameStarEq
InfixFunBindCaseHead = '('? lhs:Pat NameStarEq rhs:Pat ')'?

ExBindInner = OfTy | EqPath
EqPath = '=' Path
WithType = 'withtype' TyBind*

FunctorArg = FunctorArgNameSigExp | Spec
FunctorArgNameSigExp = 'Name' ':' SigExp

StrExp =
  StructStrExp
| PathStrExp
| AscriptionStrExp
| AppStrExp
| LetStrExp

StructStrExp = 'struct' Dec 'end'
PathStrExp = Path
AscriptionStrExp = StrExp AscriptionTail
AppStrExp = 'Name' '(' AppStrExpArg ')'
LetStrExp = 'let' Dec 'in' StrExp 'end'

// a bit annoying, but that's what my rudimentary syntax-gen requires.
AppStrExpArg = AppStrExpArgStrExp | Dec
AppStrExpArgStrExp = StrExp

AscriptionTail = Ascription SigExp
Ascription = ':' | ':>'

SigExp =
  SigSigExp
| NameSigExp
| WhereTypeSigExp
| WhereSigExp

SigSigExp = 'sig' Spec 'end'
NameSigExp = 'Name'
WhereTypeSigExp = SigExp WhereOrAnd 'type' TyVarSeq Path '=' Ty
WhereSigExp = SigExp WhereOrAnd lhs:Path '=' rhs:Path
WhereOrAnd = 'where' | 'and'

Spec = SpecWithTailInSeq*
SpecWithTailInSeq = SpecWithTail ';'?
SpecWithTail = SpecInSeq* SharingTail*
SpecInSeq = SpecOne ';'?
SharingTail = 'sharing' 'type'? PathEq*

SpecOne =
  ValSpec
| TySpec
| EqTySpec
| DatSpec
| DatCopySpec
| ExSpec
| StrSpec
| IncludeSpec

ValSpec = 'val' TyVarSeq ValDesc*
TySpec = 'type' TyDesc*
EqTySpec = 'eqtype' TyDesc*
// DatDesc and ConDesc are basically the same as DatBind and ConBind in the grammar.
DatSpec = 'datatype' DatBind* WithType?
DatCopySpec = lhs_kw:'datatype' 'Name' '=' rhs_kw:'datatype' Path
ExSpec = 'exception' ExDesc*
StrSpec = 'structure' StrDesc*
IncludeSpec = 'include' SigExp*

ValDesc = NameStarEq ':' Ty 'and'?
// the Definition only gives lowering for the `= ty` case for `type` descriptions.
TyDesc = TyVarSeq 'Name' EqTy? 'and'?
ExDesc = NameStarEq OfTy? 'and'?
StrDesc = 'Name' ':' SigExp 'and'?
EqTy = '=' Ty

PathEq = Path '='?

Exp =
  HoleExp
| WildcardExp
| OpAndalsoExp
| OpOrelseExp
| SConExp
| PathExp
| RecordExp
| SelectorExp
| ParenExp
| TupleExp
| ListExp
| VectorExp
| SeqExp
| LetExp
| AppExp
| InfixExp
| TypedExp
| AndalsoExp
| OrelseExp
| HandleExp
| RaiseExp
| IfExp
| WhileExp
| CaseExp
| FnExp

HoleExp = '...'
WildcardExp = '_'
OpAndalsoExp = 'op' 'andalso'
OpOrelseExp = 'op' 'orelse'
SConExp = SCon
PathExp = 'op'? Path
RecordExp = '{' ExpRow* '}'
SelectorExp = '#' Lab
ParenExp = '(' Exp ')'
TupleExp = '(' ExpArg* ')'
ListExp = '[' ExpArg* ']'
VectorExp = '#' ListExp
SeqExp = '(' exps_in_seq:ExpInSeq* ')'
LetExp = 'let' Dec 'in' exps_in_seq:ExpInSeq* 'end'
AppExp = func:Exp arg:Exp
InfixExp = lhs:Exp NameStarEq rhs:Exp
TypedExp = Exp ':' Ty
AndalsoExp = lhs:Exp 'andalso' rhs:Exp
OrelseExp = lhs:Exp 'orelse' rhs:Exp
HandleExp = Exp 'handle' Matcher
RaiseExp = 'raise' Exp
IfExp = 'if' cond:Exp 'then' yes:Exp 'else' no:Exp
WhileExp = 'while' cond:Exp 'do' body:Exp
CaseExp = 'case' Exp 'of' Matcher
FnExp = 'fn' Matcher

ExpRow = Lab EqExp? ','?
EqExp = '=' Exp
ExpArg = Exp ','?
ExpInSeq = Exp ';'?

// call it this instead of Match to avoid clash with rust kw
Matcher = '|'? MatchRule*
MatchRule = Pat '=>' Exp '|'?

Pat =
  WildcardPat
| SConPat
| ConPat
| RecordPat
| ParenPat
| TuplePat
| ListPat
| VectorPat
| InfixPat
| TypedPat
| AsPat
| OrPat

WildcardPat = '_'
SConPat = SCon
ConPat = 'op'? Path Pat?
RecordPat = '{' PatRow* '}'
ParenPat = '(' Pat ')'
TuplePat = '(' PatArg* ')'
ListPat = '[' PatArg* ']'
VectorPat = '#' ListPat
InfixPat = lhs:Pat NameStarEq rhs:Pat
TypedPat = Pat ':' Ty
AsPat = Pat AsPatTail
OrPat = lhs:Pat '|' rhs:Pat

PatRow = PatRowInner ','?
PatRowInner =
  RestPatRow
| LabAndPatPatRow
| LabPatRow

RestPatRow = '...'
LabAndPatPatRow = Lab '=' Pat
LabPatRow = NameStarEq TyAnnotation? AsPatTail?

AsPatTail = 'as' Pat
PatArg = Pat ','?

Ty =
  HoleTy
| WildcardTy
| TyVarTy
| RecordTy
| ConTy
| OneArgConTy
| TupleTy
| FnTy
| ParenTy

HoleTy = '...'
WildcardTy = '_'
TyVarTy = 'TyVar'
RecordTy = '{' TyRow* '}'
ConTy = TySeq? Path
// rather annoying, but this makes the parser a bit easier to write.
OneArgConTy = Ty Path
TupleTy = Ty StarTy*
FnTy = param:Ty '->' res:Ty
ParenTy = '(' Ty ')'

StarTy = '*' Ty
TyRow = Lab ':' Ty ','?

OfTy = 'of' Ty
TyAnnotation = ':' Ty

Path = NameStarEqDot*
NameStarEqDot = NameStarEq '.'?

TySeq = '(' TyArg* ')'
TyArg = Ty ','?

TyVarSeq = '('? TyVarArg* ')'?
TyVarArg = 'TyVar' ','?

Lab = 'Name' | '*' | 'IntLit'

// NameStarEq can be a Name, *, or =, maybe. though, depending on the circumstance, only * and not =
// may be additionally allowed (like for patterns).
//
// TODO maybe we should have separate classes of Name for alphanumeric and symbolic.
NameStarEq = 'Name' | '*' | '='

SCon =
  'IntLit'
| 'RealLit'
| 'WordLit'
| 'CharLit'
| 'StringLit'
